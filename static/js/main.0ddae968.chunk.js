(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{139:function(e,n){e.exports="// Given an array, rotate the array to the right by k steps, where k is non-negative.\n\n// Example 1:\n\n// Input: [1,2,3,4,5,6,7] and k = 3\n// Output: [5,6,7,1,2,3,4]\n// Explanation:\n// rotate 1 steps to the right: [7,1,2,3,4,5,6]\n// rotate 2 steps to the right: [6,7,1,2,3,4,5]\n// rotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nconst rotate = (nums, k) => {\n    for (let i = 0; i < k; i++) {\n        let temp = nums.pop();\n        nums.unshift(temp);\n    }\n};\nconsole.log(rotate([0], 1));"},140:function(e,n){e.exports="// Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\n\n// Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\n// Example 1:\n\n// Given nums = [1,1,2],\n\n// Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\n// It doesn't matter what you leave beyond the returned length.\n// Example 2:\n\n// Given nums = [0,0,1,1,1,2,2,3,3,4],\n\n// Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.\n\n// It doesn't matter what values are set beyond the returned length.\n\n/**\n * @param {number[]} nums\n * @return {number} the length or nums;\n */\n\nvar removeDuplicates = function(nums) {\n    if (!nums.length) return 0;\n    let count = 1;\n    for (let i=1; i<nums.length; i++) {\n        if (nums[i] !== nums[i-1]) {\n            nums[count] = nums[i];\n            count++;\n        }\n    }\n    return count;\n};\n\nconsole.log(removeDuplicates(null));"},141:function(e,n){e.exports="// Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\n// Example:\n\n// Input: [0,1,0,3,12]\n// Output: [1,3,12,0,0]\n// Note:\n\n// You must do this in-place without making a copy of the array.\n// Minimize the total number of operations.\n\nvar moveZeroes = function(nums) {  \n    for (let i = nums.length; i > 0; i--) {\n        if(nums[i] === 0) {\n            let temp = nums.splice(i, 1);\n            nums.push(temp);\n        }\n    }\n}\nconsole.log(moveZeroes([0]));"},142:function(e,n){e.exports="// Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\n\n// Your algorithm's runtime complexity must be in the order of O(log n).\n\n// If the target is not found in the array, return [-1, -1].\n\n// Example 1:\n\n// Input: nums = [5,7,7,8,8,10], target = 8\n// Output: [3,4]\n// Example 2:\n\n// Input: nums = [5,7,7,8,8,10], target = 6\n// Output: [-1,-1]\n\nvar searchRange = function(nums, target) {\n    if (nums.length === 0) return [-1,-1];\n    let first = 0;\n    let last = nums.length - 1;\n    let startIndex = -1;\n    let endIndex = -1;\n    for (let i = 0; i < nums.length; i++) {\n         if (nums[first] === target) {\n             startIndex = first;\n         } else {\n             first++;\n         }\n         if (nums[last] === target) {\n             endIndex = last;\n         } else {\n             last--;\n         }\n    }\n    return [startIndex, endIndex];\n }\n console.log(searchRange([],0));"},143:function(e,n){e.exports="// Given a set of distinct integers, nums, return all possible subsets (the power set).\n\n// Note: The solution set must not contain duplicate subsets.\n\n// Example:\n\n// Input: nums = [1,2,3]\n// Output:\n// [\n//   [3],\n//   [1],\n//   [2],\n//   [1,2,3],\n//   [1,3],\n//   [2,3],\n//   [1,2],\n//   []\n// ]\n\nconst dfs = (nums, startIndex, list, result) => {\n    // sanity check and return the data to stop the recursion\n    if(startIndex === nums.length) { result.push(list.slice()); return; }\n\n    // core logic\n    \n    dfs(nums, startIndex + 1, list, result);\n    list.push(nums[startIndex]);\n    dfs(nums, startIndex + 1, list, result);\n    list.pop();\n}\n\nvar subsets = function(nums) {\n    // sanity check\n    if (nums === null || nums.length === 0) return [];\n\n    let result = [];\n\n    // depth first search\n    dfs(nums, 0, [], result);\n\n    // return subset;\n    return result;\n};\n\nconsole.log(subsets([1,2,3]));"},144:function(e,n){e.exports="// Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.\n\n// Example 1:\n\n// Input: nums = [-1,0,3,5,9,12], target = 9\n// Output: 4\n// Explanation: 9 exists in nums and its index is 4\n\nconst search = (nums, target) => {\n    let start = 0, end = nums.length - 1, middle;\n    while (start < end) {\n        middle = Math.floor((start+end) / 2);\n        if (nums[middle] === target) { return middle; }\n        if (nums[middle] < target) {\n            start = middle + 1;\n        } else { \n            end = middle - 1;\n        }\n    }\n    return -1;\n}\nconsole.log(search([1,2,3,4,5,6], 9));"},145:function(e,n){e.exports="// Given two binary trees, write a function to check if they are the same or not.\n\n// Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n\n// Example 1:\n\n// Input:     1         1\n//           / \\       / \\\n//          2   3     2   3\n\n//         [1,2,3],   [1,2,3]\n\n// Output: true\n// Example 2:\n\n// Input:     1         1\n//           /           \\\n//          2             2\n\n//         [1,2],     [1,null,2]\n\n// Output: false\n// Example 3:\n\n// Input:     1         1\n//           / \\       / \\\n//          2   1     1   2\n\n//         [1,2,1],   [1,1,2]\n\n// Output: false\n\nconst isSameTree = (tree1, tree2) => {\n    if (tree1 === null || tree2 === null) { return true; }\n    if ((tree1 !== null && tree2 === null) && (tree1 === null && tree2 !== null)) { return false; }\n    if (tree1.val !== tree2.val) { return false; }\n    return isSameTree(tree1.left, tree2.left) && isSameTree(tree1.right, tree2.right);\n}"},146:function(e,n){e.exports="// mirror of itself (ie, symmetric around its center).\n\n// For example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n//     1\n//    / \\\n//   2   2\n//  / \\ / \\\n// 3  4 4  3\n// But the following [1,2,2,null,3,null,3] is not:\n//     1\n//    / \\\n//   2   2\n//    \\   \\\n//    3    3\n\nconst reverseHelper = head => {\n    if (head === null) return head;\n    let temp = head.left;\n    head.left = reverseHelper(head.right);\n    head.right = reverseHelper(temp);\n    return head;\n}\nconst sameTree = (node1, node2) => {\n    if (node1 === null && node2 === null) {\n        return true;\n    }\n    if ((node1 !== null && node2 === null) || (node1 === null && node2 !== null)) {\n        return false;\n    }\n    if (node1.val !== node2.val) {\n        return false;\n    }\n    return sameTree(node1.left, node2.left)  && sameTree(node1.right, node2.right);\n}\n\nvar isSymmetric = function(root) {  \n    if (root === null) return true;\n    let reverseTree = reverseHelper(root.left);\n    return sameTree(reverseTree, root.right);\n}\n\nconsole.log(isSymmetric(null));"},147:function(e,n){e.exports="// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n\n// For example:\n// Given binary tree [3,9,20,null,null,15,7],\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its level order traversal as:\n// [\n//   [3],\n//   [9,20],\n//   [15,7]\n// ]\n\nconst levelOrder = root => {\n    if (root === null) return [];\n    let result = [];\n    let queue = [root];\n    while (queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right)}\n        }\n        result.push(current);\n    }\n    return result;\n}\n\nconsole.log(levelOrder(null));"},148:function(e,n){e.exports="// Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n\n// For example:\n// Given binary tree [3,9,20,null,null,15,7],\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its zigzag level order traversal as:\n// [\n//   [3],\n//   [20,9],\n//   [15,7]\n// ]\n\nvar zigzagLevelOrder = function(root) {\n    if (root === null) return [];\n    let result = [];\n    let queue = [root];\n    let normal = true;\n    while (queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            normal ? current.push(head.val) : current.unshift(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(current);\n        normal = !normal;\n    }\n    return result;\n}\nconsole.log(zigzagLevelOrder(null));"},149:function(e,n){e.exports="// Given a binary tree, find its maximum depth.\n\n// The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Given binary tree [3,9,20,null,null,15,7],\n\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its depth = 3.\n\nconst maxDepth = root => {\n    let max = 0;\n    const findMaxDepth = (node, currDepth) => {\n        if (node === null) return currDepth;\n        if (currDepth > max) { max = currDepth; }\n        if (node.left !== null) { findMaxDepth(node.left, currDepth + 1); }\n        if (node.right !== null) { findMaxDepth(node.right, currDepth + 1); }\n    }\n    findMaxDepth(root, 1);\n    return max;\n}\n\nvar maxDepth2 = function(root) {\n    if (root === null) return 0;\n    return Math.max(maxDepth2(root.left), maxDepth2(root.right)) + 1;\n};\n\nconsole.log(maxDepth(null));"},150:function(e,n){e.exports="// Given preorder and inorder traversal of a tree, construct the binary tree.\n\n// Note:\n// You may assume that duplicates do not exist in the tree.\n\n// For example, given\n\n// preorder = [3,9,20,15,7]\n// inorder = [9,3,15,20,7]\n// Return the following binary tree:\n\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\nconst TreeNode = (val) => {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\nconst p2iHelper = (preorder, pStart, pEnd, inorder, iStart, iEnd) => {\n    if (iStart > iEnd) return null;\n    let value = preorder[pStart];\n    let root = new TreeNode(value);\n    let position = inorder.indexOf(value); // found out where is the value index in the iorder arrary\n    root.left = p2iHelper(preorder, pStart + 1, pStart + position - iStart, inorder, iStart, position - 1);\n    root.right =  p2iHelper(preorder, position - iEnd + pEnd + 1, pEnd, inorder, position + 1 , iEnd);\n    return root;\n}\nconst buildTree = (preorder, inorder) => {\n    // sanity check\n    if (preorder.length !== inorder.length) return null;\n    \n    //base logic\n    return p2iHelper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n}\n\nconsole.log(buildTree(null,null));"},151:function(e,n){e.exports="// Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\n// For example:\n// Given binary tree [3,9,20,null,null,15,7],\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its bottom-up level order traversal as:\n// [\n//   [15,7],\n//   [9,20],\n//   [3]\n// ]\n\nconst levelOrderBottom = root => {\n    if (root === null) return [];\n    let result = [];\n    let queue = [root];\n    while(queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.unshift(current);\n    }\n    return result;\n}\nconsole.log(levelOrderBottom(null));"},152:function(e,n){e.exports="// Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n\n// For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n// Example:\n\n// Given the sorted array: [-10,-3,0,5,9],\n\n// One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n\n//       0\n//      / \\\n//    -3   9\n//    /   /\n//  -10  5\nconst TreeNode = (val) => {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\nconst buildBST = (nums, start, end) => {\n    if (start > end) return null;\n    let mid = Math.floor((start + end) / 2);\n    let bst = new TreeNode(nums[mid]);\n    bst.left = buildBST(nums, start, mid - 1);\n    bst.right = buildBST(nums, mid + 1, end);\n    return bst;\n}\n\nconst sortedArrayToBST = nums => {\n    if (nums.length === 0) return null;\n    return buildBST(nums, 0, nums.length - 1);\n}\n\nconsole.log(sortedArrayToBST([123]));"},153:function(e,n){e.exports="// Given a binary tree, find its minimum depth.\n\n// The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Given binary tree [3,9,20,null,null,15,7],\n\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its minimum depth = 2.\n\nvar minDepth = function(root) {\n    // sanity Check\n    if (root === null) return 0;\n    const left = minDepth(root.left);\n    const right = minDepth(root.right);\n    return (left === 0 || right === 0) ? (right + left ) + 1 : Math.min(left, right) + 1;\n};"},154:function(e,n){e.exports="// Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Given the below binary tree and sum = 22,\n\n//       5\n//      / \\\n//     4   8\n//    /   / \\\n//   11  13  4\n//  /  \\      \\\n// 7    2      1\n// return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\n\nvar hasPathSum = function(root, sum) {\n    // sanity check\n    if (root === null) return false;\n    if (root.left === null && root.right === null && root.val === sum) return true;\n    return hasPathSum(root.left, sum - root.val) ||  hasPathSum(root.right, sum - root.val);\n}"},155:function(e,n){e.exports="// Given a binary tree, return the preorder traversal of its nodes' values.\n\n// Example:\n\n// Input: [1,null,2,3]\n//    1\n//     \\\n//      2\n//     /\n//    3\n\n// Output: [1,2,3]\n\nconst preorderTraversal = root => {\n    let result = [];\n    const traversal = node => {\n        if (node === null) return result;\n        result.push(node.val);\n        traversal(node.left);\n        traversal(node.right);\n    }\n    traversal(root);\n    return result;\n}\n\nconsole.log(preorderTraversal(null));"},156:function(e,n){e.exports="// Given a binary tree, return the postorder traversal of its nodes' values.\n\n// Example:\n\n// Input: [1,null,2,3]\n//    1\n//     \\\n//      2\n//     /\n//    3\n\n// Output: [3,2,1]\n\nvar postorderTraversal = function(root) {\n    let result = [];\n    const traversal = node => {\n        if (node === null) return result;\n        traversal(node.left);\n        traversal(node.right);\n        result.push(node.val);\n    }\n    traversal(root);\n    return result;\n}\nconsole.log(postorderTraversal(null));"},157:function(e,n){e.exports="// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n\n// Example:\n\n// Input: [1,2,3,null,5,null,4]\n// Output: [1, 3, 4]\n// Explanation:\n\n//    1            <---\n//  /   \\\n// 2     3         <---\n//  \\     \\\n//   5     4       <---\n\n\nconst rightSideView = root => {\n    if (root === null) { return []; }\n    let result = [];\n    let queue = [root];\n    while (queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(current[current.length - 1]);\n    }\n    return result;\n}\n\nconsole.log(rightSideView(null));\n"},158:function(e,n){e.exports="// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n// Example 1:\n\n// Input:\n// 11110\n// 11010\n// 11000\n// 00000\n\n// Output: 1\n// Example 2:\n\n// Input:\n// 11000\n// 11000\n// 00100\n// 00011\n\n// Output: 3\n\nconst updateLandToWater = (grid, i, j) => {\n    if (i< 0 || i >= grid.length || j < 0 || j>= grid[0].length || grid[i][j] !== '1') {\n        return\n    }\n    grid[i][j] = 0;\n    updateLandToWater(grid, i - 1, j);\n    updateLandToWater(grid, i + 1, j);\n    updateLandToWater(grid, i, j - 1);\n    updateLandToWater(grid, i, j + 1);\n}\n\nvar numIslands = function(grid) {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n                updateLandToWater(grid, i, j);\n            }\n        }\n    }\n    return count;\n};\n\nconsole.log(numIslands(null));"},159:function(e,n){e.exports="// Invert a binary tree.\n\n// Example:\n\n// Input:\n\n//      4\n//    /   \\\n//   2     7\n//  / \\   / \\\n// 1   3 6   9\n// Output:\n\n//      4\n//    /   \\\n//   7     2\n//  / \\   / \\\n// 9   6 3   1\n\nvar invertTree = function(root) {\n    // sanity check\n    if (root === null) { return root; }\n    let queue = [root];\n    while(queue.length > 0) {\n        let node = queue.shift();\n        let temp = node.left;\n        node.left = node.right;\n        node.right = temp;\n        if (node.left !== null) { queue.push(node.left); }\n        if (node.right !== null) { queue.push(node.right); }\n    }\n    return root;\n};\n\nconsole.log(invertTree(null));"},160:function(e,n){e.exports="// Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\n// Note: \n// You may assume k is always valid, 1 \u2264 k \u2264 BST's total elements.\n\n// Example 1:\n\n// Input: root = [3,1,4,null,2], k = 1\n//    3\n//   / \\\n//  1   4\n//   \\\n//    2\n// Output: 1\n// Example 2:\n\n// Input: root = [5,3,6,2,4,null,null,1], k = 3\n//        5\n//       / \\\n//      3   6\n//     / \\\n//    2   4\n//   /\n//  1\n// Output: 3\n\nconst kthSmallest = (root, k) => {\n    let counter = 0;\n    let kth = null;\n    let inorderTraversal = node => {\n        if (node.left !== null) { inorderTraversal(node.left); }\n        counter++;\n        if (counter === k) { kth = node; }\n        if (node.right !== null) { inorderTraversal(node.right); }\n    }\n    inorderTraversal(root);\n    return kth.val;\n}\n\nconsole.log(kthSmallest(null,0));"},161:function(e,n){e.exports="// Given a binary tree, return all root-to-leaf paths.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Input:\n\n//    1\n//  /   \\\n// 2     3\n//  \\\n//   5\n\n// Output: [\"1->2->5\", \"1->3\"]\n\n// Explanation: All root-to-leaf paths are: 1->2->5, 1->3\n\nconst binaryTreePaths = root => {\n    // sanity check\n    var result = [];\n    if (!root) { return result; }\n    const preorderTraversal = (node, content) => {\n        if(!node.left && !node.right) { result.push(content + node.val); }\n        if (node.left !== null) { preorderTraversal(node.left, content + node.val + '->'); }\n        if (node.right !== null) { preorderTraversal(node.right, content + node.val + '->'); }\n    }\n    preorderTraversal(root, '');\n    return result;\n}\n\nconsole.log(binaryTreePaths(null));"},162:function(e,n){e.exports="// Given a binary tree, find the leftmost value in the last row of the tree.\n\n// Example 1:\n// Input:\n\n//     2\n//    / \\\n//   1   3\n\n// Output:\n// 1\n// Example 2: \n// Input:\n\n//         1\n//        / \\\n//       2   3\n//      /   / \\\n//     4   5   6\n//        /\n//       7\n\n// Output:\n// 7\n// Note: You may assume the tree (i.e., the given root node) is not NULL.\n// preorder traversal - first vist the most left child and traversal back - DFS\n// leve order traversal - collect all the level node vale and get the last row of frist child - not idea solution\n\nconst findBottomLeftValue = root => {\n    let result;\n    let maxHeight = 0;\n    const preorderTraversal = (node, level) => {\n        if (node === null) return node;\n        if (level > maxHeight) {\n            result = node.val;\n            maxHeight = level;\n        }\n        preorderTraversal(node.left, level + 1);\n        preorderTraversal(node.right, level + 1);\n    }\n    preorderTraversal(root, 1);\n    return result;\n}\n\nconst findBottomLeftValue2 = root => {\n    // sanity check\n    if (root === null) return [];\n    let result;\n    let queue = [root];\n    while(queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(current);\n    }\n    return result[result.length - 1][0];\n}\n\nconsole.log(findBottomLeftValue2(null));\nconsole.log(findBottomLeftValue(null));"},163:function(e,n){e.exports="// You need to find the largest value in each row of a binary tree.\n\n// Example:\n// Input: \n//           1\n//          / \\\n//         3   2\n//        / \\   \\  \n//       5   3   9 \n\n// Output: [1, 3, 9]\n\n// level order traversal - BFS\n\nvar largestValues = function(root) {\n    // sanity check\n    if (root === null) return [];\n\n    let result = [];\n    let queue = [root];\n    while (queue.length > 0){\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(Math.max(...current));\n    }\n    return result;\n}\nconsole.log(largestValues(null));"},164:function(e,n){e.exports='// Example 1:\n// Input:\n//      1\n//     /\n//    2\n// Output:\n// [["", "1", ""],\n//  ["2", "", ""]]\n// Example 2:\n// Input:\n//      1\n//     / \\\n//    2   3\n//     \\\n//      4\n// Output:\n// [["", "", "", "1", "", "", ""],\n//  ["", "2", "", "", "", "3", ""],\n//  ["", "", "4", "", "", "", ""]]\n\n// 1.allocate empty array with "";\n// 2.DFS through the tree - preorder traversal\n// 3.calculate the position [mid] to fill node.val;\n/**\n * @param {TreeNode} root\n * @return {string[][]}\n */\nvar getTreeMaxHeight = (root) => {\n    if (root === null) return 0;\n    return Math.max(getTreeMaxHeight(root.left), getTreeMaxHeight(root.right)) + 1;\n}\n\nvar fill = (node, result, level, left, right) => {\n    // sanity checko\n    if (node === null) return;\n    let mid = Math.floor((left + right) / 2);\n    result[level - 1][mid] = node.val.toString();\n    \n    fill(node.left, result, level + 1, left, mid - 1);\n    fill(node.right, result, level + 1, mid + 1, right);\n}\n\nvar printTree = function(root) {\n    // sanity check\n    if (root === null) return root;\n    \n    // base logic\n    let result = [];\n    let maxHeight = getTreeMaxHeight(root);\n    let maxWidth = Math.pow(2, maxHeight) - 1;\n\n    for (let i = 0; i < maxHeight; i++) {\n        result.push(new Array(maxWidth).fill(\'\'));\n    }\n    \n    fill(root, result, 1, 0, maxWidth - 1);\n    return result;\n};\n\n\nconsole.log(printTree(null));'},165:function(e,n){e.exports="// Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.\n\n// For example, \n\n// Given the tree:\n//         4\n//        / \\\n//       2   7\n//      / \\\n//     1   3\n\n// And the value to search: 2\n// You should return this subtree:\n\n//       2     \n//      / \\   \n//     1   3\n// In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL.\n\n// Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.\n\nconst searchBST = (root, val) => {\n    if (root === null) return root;\n    if (root.val === val) { return root; }\n    else if (val < root.val && root.left !== null) { return searchBST(root.left, val); }\n    else if (val > root.val && root.right !== null) { return searchBST(root.right, val); }\n    else { return []; }\n}"},166:function(e,n){e.exports="// Given a binary tree, return the inorder traversal of its nodes' values.\n\n// Example:\n\n// Input: [1,null,2,3]\n//    1\n//     \\\n//      2\n//     /\n//    3\n\n// Output: [1,3,2]\n\n\nvar inorderTraversal = function(root) {\n    let result = [];\n    const traversal = head => {\n        if (head === null) return head;\n        traversal(head.left);\n        result.push(head.val);\n        traversal(head.right);\n    }\n    traversal(root);\n    return result;\n}\nconsole.log(inorderTraversal(null));"},167:function(e,n){e.exports="// Given a binary tree, determine if it is a valid binary search tree (BST).\n\n// Assume a BST is defined as follows:\n\n// The left subtree of a node contains only nodes with keys less than the node's key.\n// The right subtree of a node contains only nodes with keys greater than the node's key.\n// Both the left and right subtrees must also be binary search trees.\n// Example 1:\n\n// Input:\n//     2\n//    / \\\n//   1   3\n// Output: true\n// Example 2:\n\n//     5\n//    / \\\n//   1   4\n//      / \\\n//     3   6\n// Output: false\n// Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value\n//              is 5 but its right child's value is 4.\n\n// inorder traversal\nconst isValidBST = root => {\n    let result = [];\n    const traversal = head => {\n        if (head === null) return head;\n        traversal(head.left);\n        result.push(head.val);\n        traversal(head.right);\n    }\n    traversal(root);\n    \n    let slow = 0;\n    let fast = 1;\n    while (fast <= result.length - 1) {\n        if (result[slow] >= result[fast]) return false;\n        slow++;\n        fast++;\n    }\n    return true;\n}\n// ----------------------------------------------------------\nvar isValidBST2 = root => helper(root, null, null)\n\nvar helper = (root, min, max) => {\n  if (root === null) return true\n  if (min !== null && root.val <= min) return false\n  if (max !== null && root.val >= max) return false\n  return helper(root.left, min, root.val) && helper(root.right, root.val, max)\n}\n\nconsole.log(isValidBST(null));\nconsole.log(isValidBST2(null));"},168:function(e,n){e.exports='// // https://www.youtube.com/watch?v=vWPCm69MSfs\n\n// Given two words (beginWord and endWord), and a dictionary\'s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n\n// Only one letter can be changed at a time.\n// Each transformed word must exist in the word list. Note that beginWord is not a transformed word.\n\n// Input:\n// beginWord = "hit",\n// endWord = "cog",\n// wordList = ["hot","dot","dog","lot","log","cog"]\n\n// Output: 5\n\n// Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.\n// -----------\n\n// Example 2:\n// Input:\n// beginWord = "hit"\n// endWord = "cog"\n// wordList = ["hot","dot","dog","lot","log"]\n\n// Output: 0\n\n// Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.\n\n// function ladderLength(beginWord, endWord, wordList) {\n//     let len = 1;\n//     let result = [];\n//     let queue = [beginWord];\n//     const dict = new Set(wordList);\n//     const seen = new Set(queue);\n//     while (queue.length) {\n//       const next = [];\n//       for (let v of queue) {\n//         if (v === endWord) {\n//           console.log(result);\n//           return len;\n//         }\n        \n//         const arr = v.split(\'\');\n//         for (let i = 0; i < arr.length; i++) {\n//           for (let d = 0; d < 26; d++) {\n//             arr[i] = String.fromCharCode(97+d);\n//             const nv = arr.join(\'\');\n//             if (!seen.has(nv) && dict.has(nv)) {\n//               next.push(nv);\n//               seen.add(nv);\n//             }\n//             arr[i] = v[i];\n//           }\n//         }\n//         result.push(...next);\n//       }\n//       queue = next;\n//       len++;\n//     }\n    \n//     return 0;\n//   }\n\nconst swapLetterInWord = (string, index, replace) =>{\n  return string.substring(0, index) + replace + string.substring(index + 1);\n}\nconst ladderLength = (beginWord, endWorld, wordList) => {\n    wordList.splice(wordList.indexOf(beginWord), 1);\n    let level = 1;\n    let current = 1;\n    let next = 0;\n    let queue = [beginWord];\n    while(queue.length > 0) {\n      let word = queue.shift();\n      current--;\n      for (let i = 0; i < word.length; i++) {\n        for (let j = \'a\'.charCodeAt(0); j < \'z\'.charCodeAt(0); j++) {\n          let temp = swapLetterInWord(word, i, String.fromCharCode(j));\n          if (wordList.indexOf(temp) > -1) {\n            if (temp === endWorld) return level + 1;\n            next++;\n            queue.push(temp);\n            wordList.splice(wordList.indexOf(temp), 1);\n          }\n        }\n      }\n      if (current === 0) {\n        current = next;\n        next = 0;\n        level++;\n      }\n    }\n    return 0;\n}\nconsole.log(ladderLength("hit", "cog", ["hit","hot","dot","dog","lot","log","cog"]));'},169:function(e,n){e.exports='// Given a string s, partition s such that every substring of the partition is a palindrome.\n\n// Return all possible palindrome partitioning of s.\n\n// Example:\n\n// Input: "aab"\n// Output:\n// [\n//   ["aa","b"],\n//   ["a","a","b"]\n// ]\n\n/**\n * @param {string} s\n * @return {string[][]}\n */\n\nconst isPalidrome = str => {\n    let start = 0;\n    let end = str.length - 1;\n    while ( start <= end) {\n        if (str[start] !== str[end]) { return false}\n        start++;\n        end--;\n    }\n    return true;\n}\nconst helper = (str, startIndex, partition, result) => {\n    // sanity check\n    if (startIndex === str.length) {\n        result.push(partition.slice());\n        return;\n    }\n    // core logic\n    for (let i = startIndex; i < str.length; i++) {\n        let subStr = str.slice(startIndex, i + 1);\n        if (!isPalidrome(subStr)) {\n            continue;\n        }\n\n        partition.push(subStr);\n        helper(str, i + 1, partition, result);\n        partition.pop();\n    }\n}\n\nconst partition = (str) => {\n    // sanity check\n    if (str === null || str.length === 0) return [];\n  \n    // create result array\n    let result = [];\n\n    // base logic - recursive\n    helper(str, 0, [], result);\n\n    // return\n    return result;\n};\n\nconsole.log(partition(\'aab\'));'},170:function(e,n){e.exports='// Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\n\n// A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\n\n// Example:\n\n// Input: "23"\n// Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n\n/**\n * @param {string} digits\n * @return {string[]}\n */\n\nconst helper = (letters, digits, startIndex, combination, result) => {\n    // sanity check\n    if (startIndex === digits.length) { result.push(combination.join(\'\')); return; }\n    \n    // core logic\n    for (let i = 0; i < letters[digits[startIndex]].length; i++){\n        const c = letters[digits[startIndex]][i];\n        combination.push(c);\n        helper(letters, digits, startIndex + 1 , combination, result);\n        combination.pop();\n    }\n}\nvar letterCombinations = function(digits) {\n    const letters = {\n        2: \'abc\',\n        3: \'def\',\n        4: \'ghi\',\n        5: \'jkl\',\n        6: \'mno\',\n        7: \'pqrs\',\n        8: \'tuv\',\n        9: \'wxyz\'\n    };\n    // sanity check\n    if (digits.length === 0) return [];\n        \n    // create empty array to store the combinations\n    let result = [];\n    \n    // base logice - recursive\n    helper(letters, digits, 0, [], result);\n\n    // return\n    return result;\n};\n\nconsole.log(letterCombinations("23"));\n\n'},171:function(e,n){e.exports="// Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n// The same repeated number may be chosen from candidates unlimited number of times.\n\n// Note:\n\n// All numbers (including target) will be positive integers.\n// The solution set must not contain duplicate combinations.\n// Example 1:\n\n// Input: candidates = [2,3,6,7], target = 7,\n// A solution set is:\n// [\n//   [7],\n//   [2,2,3]\n// ]\n\nconst helper = (candidates, target, startIndex, combination, result) => {\n    // sanity check \n    if (target === 0) { result.push(combination.slice()) }\n    \n    for (let i = startIndex; i < candidates.length; i++) {\n        if (target < candidates[i]) break;\n        if (i !== 0 && candidates[i] === candidates[i - 1]) continue;\n        \n        combination.push(candidates[i]);\n        helper(candidates, target - candidates[i], i, combination, result);\n        combination.pop();\n    }\n}\n\nconst combinationSum = (candidates, target) => {\n    // sanity check\n    if (target === 0) return [];\n    if (candidates === null && candidates.length === 0) return [];\n    \n    // create result array\n    let result = [];\n    \n    // sort candidates\n    candidates.sort((a, b) => a - b);\n    \n    // call recursion\n    helper(candidates, target, 0, [], result);\n    return result;   \n}\n\nconsole.log(combinationSum([1,3,4], 4));"},172:function(e,n){e.exports="// Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n// Each number in candidates may only be used once in the combination.\n\n// Note:\n\n// All numbers (including target) will be positive integers.\n// The solution set must not contain duplicate combinations.\n// Example 1:\n\n// Input: candidates = [10,1,2,7,6,1,5], target = 8,\n// A solution set is:\n// [\n//   [1, 7],\n//   [1, 2, 5],\n//   [2, 6],\n//   [1, 1, 6]\n// ]\n\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nconst helper = (candidates, target, startIndex, combination, result) => {\n    // sanity check\n    if (target === 0) { result.push(combination.slice()); }\n\n    // core logic\n    for (let i = startIndex; i < candidates.length; i++) {\n        if (target < candidates[i]) break;\n        if (i !== startIndex && candidates[i] === candidates[i-1]) continue;\n        combination.push(candidates[i]);\n        helper(candidates, target - candidates[i], i + 1, combination, result);\n        combination.pop();\n    }\n}\n\nvar combinationSum2 = function(candidates, target) {\n    // sanity check\n    if (target === 0) return [];\n    if (candidates === null && candidates.length === 0) return [];\n\n    // create empty result array\n    let result = [];\n\n    // sort candidate\n    candidates.sort(( a, b) => a - b);\n\n    // basic logic recursion\n    helper(candidates, target, 0, [], result);\n    \n    // return\n    return result;\n};\n\nconsole.log(combinationSum2(null,null));"},173:function(e,n){e.exports="// Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n\n// Example:\n\n// Input: n = 4, k = 2\n// Output:\n// [\n//   [2,4],\n//   [3,4],\n//   [2,3],\n//   [1,2],\n//   [1,3],\n//   [1,4],\n// ]\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\n\nconst helper = (nums, k, startIndex, combination, result) => {\n    // sanity check\n    if (combination.length === k) { result.push(combination.slice()); }\n    // core logic \n    for (let i = startIndex; i < nums.length; i++) {\n        combination.push(nums[i]);\n        helper(nums, k, i + 1, combination, result) ;\n        combination.pop();\n    }\n}\n\nvar combine = function(n, k) {\n    // sanity check\n    if (n === 0 || k === 0) { return []}\n    \n    let result = [];\n    let nums = [];\n    for (let i = 1; i <= n; i++) { nums.push(i); }\n    \n    helper(nums, k, 0, [], result);\n    return result;\n};\n\nconsole.log(combine(4,4));"},174:function(e,n){e.exports="// You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\n// Example 1:\n\n// Input: coins = [1, 2, 5], amount = 11\n// Output: 3 \n// Explanation: 11 = 5 + 5 + 1\n\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    var dp=new Array(amount+1);\n    dp.fill(Number.MAX_VALUE-1);\n    dp[0]=0;\n    for(var i=1;i<=amount;i++)\n    {\n        for(var j=0;j<coins.length;j++) {\n            if(coins[j]<=i){\n                dp[i]=Math.min(dp[i-coins[j]]+1, dp[i]);\n            }\n        }\n    }\n   return dp[amount] === Number.MAX_VALUE-1 ? -1:dp[amount];  \n};\n\nconsole.log(coinChange(12));"},175:function(e,n){e.exports="// Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n\n// You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n// Example:\n\n// Given nums = [2, 7, 11, 15], target = 9,\n\n// Because nums[0] + nums[1] = 2 + 7 = 9,\n// return [0, 1].\n\nconst twoSum = (nums, target) => {\n    // sanity check\n    if (nums === null) { return []; }\n    let map = {};\n    for (let i = 0; i < nums.length; i++) {\n        let current = nums[i];\n        let counter = target - current;\n        if (map[current] === undefined) {\n            map[counter] = i;\n        } else {\n            return [map[current], i];\n        }\n    }\n}\nconsole.log(twoSum([],0));"},176:function(e,n){e.exports="// Given an array of integers, find if the array contains any duplicates.\n\n// Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n// Example 1:\n\n// Input: [1,2,3,1]\n// Output: true\n// Example 2:\n\n// Input: [1,2,3,4]\n// Output: false\n// Example 3:\n\n// Input: [1,1,1,3,3,4,3,2,4,2]\n// Output: true\n\nconst containsDuplicate = nums => {\n    let map = {};\n    for (let i = 0; i < nums.length; i++) {\n        let current = nums[i];\n        if(map[current] === undefined) {\n            map[current] = true;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\nconsole.log(containsDuplicate(null));"},177:function(e,n){e.exports='// A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.\n\n// Now given an M x N matrix, return True if and only if the matrix is Toeplitz.\n \n\n// Example 1:\n\n// Input:\n// matrix = [\n//   [1,2,3,4],\n//   [5,1,2,3],\n//   [9,5,1,2]\n// ]\n// Output: True\n// Explanation:\n// In the above grid, the diagonals are:\n// "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".\n// In each diagonal all elements are the same, so the answer is True.\n\nconst isToeplitzMatrix = matrix => {\n    for (let i = 0; i < matrix.length - 1; i++) {\n        for(let j = 0; j < matrix[0].length - 1; j++) {\n           if (matrix[i][j] !== matrix[i+1][j+1]) return false;\n        }\n    }\n    return true;\n}\nconsole.log(isToeplitzMatrix(null));'},178:function(e,n){e.exports='// You\'re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.\n\n// The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".\n\n// Example 1:\n\n// Input: J = "aA", S = "aAAbbbb"\n// Output: 3\n// Example 2:\n\n// Input: J = "z", S = "ZZ"\n// Output: 0\n\nconst numJewelsInStones = (jStone, sStone ) => {\n    let result = 0;\n    let map = {};\n    for (let j = 0; j < jStone.length; j++) {\n        map[jStone[j]] = true;\n    }\n\n    for (let s = 0; s < sStone.length; s++) {\n        if (map[sStone[s]]) { result++; }\n    }\n    return result;\n}\nconsole.log(numJewelsInStones(null,null));'},179:function(e,n){e.exports='// International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.\n\n// For convenience, the full table for the 26 letters of the English alphabet is given below:\n\n// [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]\n// Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cab" can be written as "-.-.-....-", (which is the concatenation "-.-." + "-..." + ".-"). We\'ll call such a concatenation, the transformation of a word.\n\n// Return the number of different transformations among all words we have.\n\n// Example:\n// Input: words = ["gin", "zen", "gig", "msg"]\n// Output: 2\n// Explanation: \n// The transformation of each word is:\n// "gin" -> "--...-."\n// "zen" -> "--...-."\n// "gig" -> "--...--."\n// "msg" -> "--...--."\n\n// There are 2 different transformations, "--...-." and "--...--.".\n\nvar uniqueMorseRepresentations = function(words) {\n    let morseCodeLookup = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."];\n    let translatedWords = [];\n    words.forEach(word => {\n        let wordSplit = word.split(\'\');\n        let compiledWord = \'\';\n        wordSplit.forEach((character, idx) => {\n            compiledWord += morseCodeLookup[word.charCodeAt(idx) - 97];\n        })\n        translatedWords.push(compiledWord);\n    });\n    \n    let filteredWords = [];\n    translatedWords.forEach(word => {\n        if(!filteredWords.includes(word)) filteredWords.push(word);\n    })\n    return filteredWords.length;\n};\n\nconsole.log(uniqueMorseRepresentations(\'\'));'},180:function(e,n){e.exports="// Given a binary tree\n\n// struct TreeLinkNode {\n//   TreeLinkNode *left;\n//   TreeLinkNode *right;\n//   TreeLinkNode *next;\n// }\n// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\n// Initially, all next pointers are set to NULL.\n\n// Note:\n\n// You may only use constant extra space.\n// Recursive approach is fine, implicit stack space does not count as extra space for this problem.\n// You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\n// Example:\n\n// Given the following perfect binary tree,\n\n//      1\n//    /  \\\n//   2    3\n//  / \\  / \\\n// 4  5  6  7\n// After calling your function, the tree should look like:\n\n//      1 -> NULL\n//    /  \\\n//   2 -> 3 -> NULL\n//  / \\  / \\\n// 4->5->6->7 -> NULL\n\nconst connect = node => {\n    // sanity check\n    if (node === null) return;\n    if (node.left !== null) {\n        node.left.next = node.right;\n    }\n    if (node.next !== null && node.right !== null) {\n        node.right.next = node.next.left;\n    }\n    connect(node.left);\n    connect(node.right);\n}"},181:function(e,n){e.exports="// Given a linked list, determine if it has a cycle in it.\n\n// Follow up:\n// Can you solve it without using extra space?\n\nconst hasCycle = head => {\n    if (head === null) return false;\n    let slow = head;\n    let fast = head;\n    while(fast.next !== null && fast.next.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) return true;\n    }\n    return false;\n}\n\nconsole.log(hasCycle(null));"},182:function(e,n){e.exports="// Sort a linked list in O(n log n) time using constant space complexity.\n\n// Example 1:\n\n// Input: 4->2->1->3\n// Output: 1->2->3->4\n// Example 2:\n\n// Input: -1->5->3->4->0\n// Output: -1->0->3->4->5\n \nconst ListNode = (val) => {\n    this.val = val;\n    this.next = null;\n}\nconst mergeTwoLists = (list1, list2) => {\n    let mergeTwoList = new ListNode(0);\n    let current = mergeTwoList;\n    while(list1 !== null && list2 !== null) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    if (list1 === null) { current.next = list2; }\n    if (list2 === null) { current.next = list1; }\n    return mergeTwoList.next;\n}\nconst sortList = head => {\n    if (head === null || head.next === null) return head;\n    let pre = head, slow = head, fast = head;\n    while(fast !== null && fast.next !== null) {\n        pre = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    pre.next = null;\n    return mergeTwoLists(sortList(head), sortList(slow))\n}"},183:function(e,n){e.exports="// Given a linked list, remove the n-th node from the end of list and return its head.\n\n// Example:\n\n// Given linked list: 1->2->3->4->5, and n = 2.\n\n// After removing the second node from the end, the linked list becomes 1->2->3->5.\nconst ListNode = val => {\n    this.val = val;\n    this.next = null;\n}\nconst removeNthFromEnd = (head, n) => {\n    if (head === null && n === 0) return head;\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let slow = dummyNode;\n    let fast = dummyNode;\n\n    for (let i = 0; i < n; i++) {\n        fast = fast.next;\n    }\n\n    while(fast.next) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    slow.next = slow.next.next;\n    return dummyNode.next;\n}\n\nconsole.log(removeNthFromEnd(new ListNode(0), 1));"},184:function(e,n){e.exports="// You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\n// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n// Example:\n\n// Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n// Output: 7 -> 0 -> 8\n// Explanation: 342 + 465 = 807.\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nconst ListNode = val => {\n    this.val = val;\n    this.next = null;\n};\nvar addTwoNumbers = function(l1, l2) {\n    let twoSum = new ListNode(0);\n    let cur = twoSum;\n    let carryOver = 0;\n    while(l1 || l2) {\n       let val1 = l1 && l1.val !== null ? l1.val : 0;\n       let val2 = l2 && l2.val !== null ? l2.val : 0;\n       let sum = val1 + val2 + carryOver;\n       if (sum >= 10) {\n          cur.next = new ListNode(sum % 10);\n          carryOver = Math.floor(sum / 10);\n       } else {\n          cur.next = new ListNode(sum);\n          carryOver = 0;\n       }\n       cur = cur.next;\n       l1 = l1 && l1.next;\n       l2 = l2 && l2.next;\n    }\n    if (carryOver > 0) {\n        cur.next = new ListNode(carryOver);\n    }\n    return twoSum.next;\n  };\n\n  console.log(addTwoNumbers(null, null));"},185:function(e,n){e.exports="// Remove all elements from a linked list of integers that have value val.\n\n// Example:\n\n// Input:  1->2->6->3->4->5->6, val = 6\n// Output: 1->2->3->4->5\n\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nconst ListNode = (val) => {\n    this.val = val;\n    this.next = null;\n}\nvar removeElements = (head, val) => {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    head = dummyNode;\n    while(head.next !== null) {\n        if (head.next.val === val) {\n            head.next = head.next.next;\n        } else {\n            head = head.next;\n        }\n    }\n    return dummyNode.next\n}\nconsole.log(removeElements(null,null));"},186:function(e,n){e.exports="// Reverse a singly linked list.\n\n// Example:\n\n// Input: 1->2->3->4->5->NULL\n// Output: 5->4->3->2->1->NULL\n\nconst reverseList = head => {\n    if (head === null) return head;\n    let firstNode = head;\n    let currentNode = head.next;\n    while(currentNode) {\n        head.next = currentNode.next;\n        currentNode.next = firstNode;\n        firstNode = currentNode\n        currentNode = head.next;\n    }\n    return firstNode;\n}\nconsole.log(reverseList(null));"},187:function(e,n){e.exports="// Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n// Example:\n\n// Input: 1->2->4, 1->3->4\n// Output: 1->1->2->3->4->4\n\nconst ListNode = val => {\n    this.val = val;\n    this.next = null;\n}\nconst mergeTwoLists = (list1, list2) => {\n    let mergedList = new ListNode(0);\n    let prev = mergedList;\n    while(list1 !== null && list2 !== null) {\n        if (list1.val <= list2.val) {\n            prev.next = list1;\n            list1 = list1.next;\n        } else {\n            prev.next = list2;\n            list2 = list2.next;\n        }\n        prev = prev.next;\n    }\n    if (list1 === null) { prev.next = list2; }\n    if (list2 === null) { prev.next = list1;}\n    return mergedList.next;\n}\nconsole.log(mergeTwoLists(null,null));"},188:function(e,n){e.exports="// Given a singly linked list, determine if it is a palindrome.\n\n// Example 1:\n\n// Input: 1->2\n// Output: false\n// Example 2:\n\n// Input: 1->2->2->1\n// Output: true\n// Follow up:\n// Could you do it in O(n) time and O(1) space?\n\nconst reverseList = head => {\n    if (head === null) return head;\n    let firstNode = head;\n    let currentNode = head.next;\n    while (currentNode) {\n        head.next = currentNode.next;\n        currentNode.next = firstNode;\n        firstNode = currentNode;\n        currentNode = head.next;\n    }\n    return firstNode;\n}\nconst isPalindrome = head =>{\n    if (head === null || head.next === null) return true;\n    let slow = head;\n    let fast = head;\n    while (fast.next !== null && fast.next.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    slow.next = reverseList(slow.next);\n    slow = slow.next;\n    \n    while (slow != null) {\n        if (slow.val !== head.val) return false;\n        slow = slow.next;\n        head = head.next;\n    }\n    return true;\n}\n\nconsole.log(isPalindrome(null));\n"},189:function(e,n){e.exports="// Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\n\n// Given linked list -- head = [4,5,1,9], which looks like following:\n\n//     4 -> 5 -> 1 -> 9\n// Example 1:\n\n// Input: head = [4,5,1,9], node = 5\n// Output: [4,1,9]\n// Explanation: You are given the second node with value 5, the linked list\n//              should become 4 -> 1 -> 9 after calling your function.\n\nconst deleteNode = node => {\n    node.next = node.next.next;\n    node.val = node.next.val;\n}\nconsole.log(deleteNode(null));"},190:function(e,n){e.exports="// Given a sorted linked list, delete all duplicates such that each element appear only once.\n\n// Example 1:\n\n// Input: 1->1->2\n// Output: 1->2\n// Example 2:\n\n// Input: 1->1->2->3->3\n// Output: 1->2->3\n\nconst deleteDuplicates = head => { \n    if (head === null) { return head; }\n    let current = head;\n    while (current) {\n        if(current.next && current.next.val === current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\nconsole.log(deleteDuplicates(null));"},191:function(e,n){e.exports="// Given a non-empty, singly linked list with head node head, return a middle node of linked list.\n\n// If there are two middle nodes, return the second middle node.\n\n// Example 1:\n\n// Input: [1,2,3,4,5]\n// Output: Node 3 from this list (Serialization: [3,4,5])\n// The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).\n// Note that we returned a ListNode object ans, such that:\n// ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\n\nvar middleNode = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};\n\nconsole.log(middleNode(null));"},192:function(e,n){e.exports="// Given a collection of distinct integers, return all possible permutations.\n\n// Example:\n\n// Input: [1,2,3]\n// Output:\n// [\n//   [1,2,3],\n//   [1,3,2],\n//   [2,1,3],\n//   [2,3,1],\n//   [3,1,2],\n//   [3,2,1]\n// ]\n\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst helper = (nums, list, result) => {\n    // sanity check\n    if (list.length === nums.length) { result.push(list.slice()); }\n\n    // core logic\n    for (let i = 0; i < nums.length; i++) {\n        if (list.includes(nums[i])) { continue; }\n        list.push(nums[i]);\n        helper(nums, list, result );\n        list.pop();\n    }\n}\nconst permute = nums => {\n    // sanity check\n    if (nums === null || nums.length === 0) return [];\n\n    // create an empty result array\n    let result = [];\n\n    // base logic\n    helper(nums, [], result);\n    \n    // return\n    return result;\n};\n\nconsole.log(permute([1,2,3,4]));"},193:function(e,n){e.exports="// Given a string containing only digits, restore it by returning all possible valid IP address combinations.\n\n// Example:\n\n// Input: \"25525511135\"\n// Output: [\"255.255.11.135\", \"255.255.111.35\"]\n\n/**\n * @param {string} s\n * @return {string[]}\n */\n\n// function restoreIpAddresses2(s) {\n//     const res = [];\n//     dfs([], 0);\n//     return res;\n    \n//     function dfs(prefix, idx) {\n//       if (prefix.length === 4 && idx === s.length) {\n//         res.push(prefix.join('.'));\n//         return;\n//       }\n      \n//       if (prefix.length === 4 || idx === s.length) {\n//         return;\n//       }\n      \n//       for (let r = idx; r < s.length; r++) {\n//         if (r !== idx && s[idx] === '0') return;\n        \n//         const num = parseInt(s.slice(idx, r+1));\n//         if (num > 255) {\n//           return;\n//         }\n//         prefix.push(num);\n//         dfs(prefix, r+1);\n//         prefix.pop();\n//       }\n//     }\n//   }\n\n\nconst dfs = (str, idx, combinations, res) => {\n    // once the combination contains 4 sets and index of string is at the end \n    // push the combination to result \n    if (combinations.length === 4 && idx === str.length) {\n      res.push(combinations.join('.'));\n      return;\n    }\n    \n    if (combinations.length === 4 || idx === str.length) return;\n    \n    for (let i = idx; i < str.length; i++) {\n      // a combination set should be less than 255\n      const num = parseInt(str.slice(idx, i+1));\n      if (i !== idx && str[idx] === '0') return;\n      if (num > 255) return;\n\n      combinations.push(num);\n      dfs(str, i+1, combinations, res);\n      combinations.pop();\n    }\n}\nvar restoreIpAddresses = function(str) {\n    // sanity check\n    if (str === null || str.length === 0) { return []}\n\n    // create empty array to store result\n    let result = [];\n\n    // base logic - recursion\n    dfs(str, 0, [], result);\n\n    // result\n    return result;\n};\n\nconsole.log(restoreIpAddresses('25525511135'));"},194:function(e,n){e.exports="// Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\n\n// The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\n\n// Note:\n\n// Your returned answers (both index1 and index2) are not zero-based.\n// You may assume that each input would have exactly one solution and you may not use the same element twice.\n// Example:\n\n// Input: numbers = [2,7,11,15], target = 9\n// Output: [1,2]\n// Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.\n\nconst twoSum = (nums, target) => {\n    let start = 0;\n    let end = nums.length - 1;\n    while (start < end) {\n        let sum = nums[start] + nums[end];\n        if(sum === target) { return [start + 1,end + 1] }\n        else if (sum < target) {\n            start++;\n        } else {\n            end--;\n        }\n    }\n    return null;\n}\n\nconsole.log(twoSum(null));"},195:function(e,n){e.exports="// Say you have an array for which the ith element is the price of a given stock on day i.\n\n// Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\n// Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\n// Example 1:\n\n// Input: [7,1,5,3,6,4]\n// Output: 7\n// Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n//              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\nvar maxProfit = price => {\n    let res = 0;\n    let cur = price[0];\n    for (let i = 1; i < price.length; i++) {\n        if (price[i] > cur) {\n            res += price[i] - cur;\n        }\n        cur = price[i];\n    }\n    return res;\n}\nconsole.log(maxProfit(''));"},196:function(e,n){e.exports="// Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\n// Note: For the purpose of this problem, we define empty string as valid palindrome.\n\n// Example 1:\n\n// Input: \"A man, a plan, a canal: Panama\"\n// Output: true\n// Example 2:\n\n// Input: \"race a car\"\n// Output: false\n\nconst isPalindrome = str => {\n    const tempStr = str.replace(/[^\\w]/g, '').toLowerCase();\n    let left = 0;\n    let right = tempStr.length - 1;\n    while (left < right) {\n        if (tempStr[left] !== tempStr[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\nconsole.log(isPalindrome(''));"},197:function(e,n){e.exports='// Write a function that takes a string as input and returns the string reversed.\n\n// Example 1:\n\n// Input: "hello"\n// Output: "olleh"\n// Example 2:\n\n// Input: "A man, a plan, a canal: Panama"\n// Output: "amanaP :lanac a ,nalp a ,nam A"\n\nvar reverseString = function(s) {\n    var newString = \'\';\n    for (let i = s.length - 1; i >= 0 ; i --) {\n        newString += s[i];\n    }\n    return newString;\n};\n\nconsole.log(reverseString(\'123\'));'},198:function(e,n){e.exports='// Given a 32-bit signed integer, reverse digits of an integer.\n\n// Example 1:\n// Input: 123\n// Output: 321\n\n// Example 2:\n// Input: -123\n// Output: -321\n\n// Example 3:\n// Input: 120\n// Output: 21\n\nconst reverse = number => {\n    let y = Math.abs(number);\n    if(y.toString(2).length > 31) return 0;\n    let arr = y.toString().split("").reverse();\n    if(Number(arr.join("")).toString(2).length > 31) return 0;\n    let z = Number(arr.join(""));\n    return number >= 0 ? z : -z;\n}\n\nconsole.log(reverse(123));'},201:function(e,n,t){e.exports=t(395)},206:function(e,n,t){},208:function(e,n,t){},212:function(e,n,t){},389:function(e,n,t){},391:function(e,n,t){},393:function(e,n,t){var r={"./Array/189-rotate-array":139,"./Array/189-rotate-array.js":139,"./Array/26-remove-duplicates-from-sorted-array":140,"./Array/26-remove-duplicates-from-sorted-array.js":140,"./Array/283-remove-zero":141,"./Array/283-remove-zero.js":141,"./Array/34-find-first-last-element-array":142,"./Array/34-find-first-last-element-array.js":142,"./BackTracking/78-subsets":143,"./BackTracking/78-subsets.js":143,"./BinarySearch/704-binarySearch":144,"./BinarySearch/704-binarySearch.js":144,"./BinarySearchTree/100-same-tree":145,"./BinarySearchTree/100-same-tree.js":145,"./BinarySearchTree/101-symmetric-tree":146,"./BinarySearchTree/101-symmetric-tree.js":146,"./BinarySearchTree/102-binary-tree-level-order-traversal":147,"./BinarySearchTree/102-binary-tree-level-order-traversal.js":147,"./BinarySearchTree/103-binary-tree-zigzag-level-order-traversal":148,"./BinarySearchTree/103-binary-tree-zigzag-level-order-traversal.js":148,"./BinarySearchTree/104-max-depth-of-binary-tree":149,"./BinarySearchTree/104-max-depth-of-binary-tree.js":149,"./BinarySearchTree/105-preorder-to-inorder-traversal":150,"./BinarySearchTree/105-preorder-to-inorder-traversal.js":150,"./BinarySearchTree/107-binary-tree-level-order-traversal":151,"./BinarySearchTree/107-binary-tree-level-order-traversal.js":151,"./BinarySearchTree/108-convert-array-bst":152,"./BinarySearchTree/108-convert-array-bst.js":152,"./BinarySearchTree/111-minimum-depth-of-binary-tree":153,"./BinarySearchTree/111-minimum-depth-of-binary-tree.js":153,"./BinarySearchTree/112-path-sum":154,"./BinarySearchTree/112-path-sum.js":154,"./BinarySearchTree/144-binary-tree-preorder-traversal":155,"./BinarySearchTree/144-binary-tree-preorder-traversal.js":155,"./BinarySearchTree/145-binary-tree-postorder-traversal":156,"./BinarySearchTree/145-binary-tree-postorder-traversal.js":156,"./BinarySearchTree/199-binary-tree-right-side-view":157,"./BinarySearchTree/199-binary-tree-right-side-view.js":157,"./BinarySearchTree/200-number-island":158,"./BinarySearchTree/200-number-island.js":158,"./BinarySearchTree/226-invert-binary-tree":159,"./BinarySearchTree/226-invert-binary-tree.js":159,"./BinarySearchTree/230-kth-element":160,"./BinarySearchTree/230-kth-element.js":160,"./BinarySearchTree/257-binary-tree-paths":161,"./BinarySearchTree/257-binary-tree-paths.js":161,"./BinarySearchTree/513-find-bottom-left-tree-value":162,"./BinarySearchTree/513-find-bottom-left-tree-value.js":162,"./BinarySearchTree/515-largest-value-tree-row":163,"./BinarySearchTree/515-largest-value-tree-row.js":163,"./BinarySearchTree/655-PrintBST":164,"./BinarySearchTree/655-PrintBST.js":164,"./BinarySearchTree/700-searchBST":165,"./BinarySearchTree/700-searchBST.js":165,"./BinarySearchTree/94-binary-tree-inorder-traversal":166,"./BinarySearchTree/94-binary-tree-inorder-traversal.js":166,"./BinarySearchTree/98-validate-binary-search-tree":167,"./BinarySearchTree/98-validate-binary-search-tree.js":167,"./BreadthFirstSearch/127-word-ladder":168,"./BreadthFirstSearch/127-word-ladder.js":168,"./Combination/131-palindrome-partition":169,"./Combination/131-palindrome-partition.js":169,"./Combination/17-phone-letter-combine":170,"./Combination/17-phone-letter-combine.js":170,"./Combination/39-combination-sum":171,"./Combination/39-combination-sum.js":171,"./Combination/40-combination-sum-ii":172,"./Combination/40-combination-sum-ii.js":172,"./Combination/77-combinations":173,"./Combination/77-combinations.js":173,"./DynamicProgramming/322-coin-change":174,"./DynamicProgramming/322-coin-change.js":174,"./HashTable/1-two-sum":175,"./HashTable/1-two-sum.js":175,"./HashTable/217-contains-duplicate":176,"./HashTable/217-contains-duplicate.js":176,"./HashTable/766-toeplitz-matrix":177,"./HashTable/766-toeplitz-matrix.js":177,"./HashTable/771-jewels-and-stones":178,"./HashTable/771-jewels-and-stones.js":178,"./HashTable/804-morse-code":179,"./HashTable/804-morse-code.js":179,"./LinkedList/116-pointers-next-right-node":180,"./LinkedList/116-pointers-next-right-node.js":180,"./LinkedList/141-linked-list-cycle":181,"./LinkedList/141-linked-list-cycle.js":181,"./LinkedList/148-sorted-linked-list":182,"./LinkedList/148-sorted-linked-list.js":182,"./LinkedList/19-remove-nth-node-from-end-of-list":183,"./LinkedList/19-remove-nth-node-from-end-of-list.js":183,"./LinkedList/2-add-two-linked":184,"./LinkedList/2-add-two-linked.js":184,"./LinkedList/203-remove-linked-list-elements":185,"./LinkedList/203-remove-linked-list-elements.js":185,"./LinkedList/206-reverse-linked-list":186,"./LinkedList/206-reverse-linked-list.js":186,"./LinkedList/21-merge-two-sorted-lists":187,"./LinkedList/21-merge-two-sorted-lists.js":187,"./LinkedList/234-palindrome-linked-list":188,"./LinkedList/234-palindrome-linked-list.js":188,"./LinkedList/237-delete-linked-list":189,"./LinkedList/237-delete-linked-list.js":189,"./LinkedList/83-remove-duplicates-from-sorted-list":190,"./LinkedList/83-remove-duplicates-from-sorted-list.js":190,"./LinkedList/876-middle-of-the-linked-list":191,"./LinkedList/876-middle-of-the-linked-list.js":191,"./Permutations/46-permutations":192,"./Permutations/46-permutations.js":192,"./Permutations/93-restore-ip-addresses":193,"./Permutations/93-restore-ip-addresses.js":193,"./TwoPointer/167-two-sum-II":194,"./TwoPointer/167-two-sum-II.js":194,"./_misc/122-best-time-to-buy-and-sell-stock":195,"./_misc/122-best-time-to-buy-and-sell-stock.js":195,"./_misc/125-valid-palindrome":196,"./_misc/125-valid-palindrome.js":196,"./_misc/344-reverse-string":197,"./_misc/344-reverse-string.js":197,"./_misc/7-revese-integer":198,"./_misc/7-revese-integer.js":198};function a(e){var n=i(e);return t(n)}function i(e){var n=r[e];if(!(n+1)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n}a.keys=function(){return Object.keys(r)},a.resolve=i,e.exports=a,a.id=393},395:function(e,n,t){"use strict";t.r(n);for(var r=t(0),a=t.n(r),i=t(34),l=t.n(i),o=t(397),s=(t(206),t(25)),u=t(26),d=t(28),c=t(27),m=t(29),h=t(399),p=t(398),f=t(396),g=(t(208),function(){return a.a.createElement("header",{id:"header"},a.a.createElement("div",{className:"avatar"},"TC"),a.a.createElement("nav",{className:"links"},a.a.createElement("ul",null,a.a.createElement("li",null,a.a.createElement(f.a,{to:"/"},"Home")),a.a.createElement("li",null,a.a.createElement(f.a,{to:"/resume"},"resume")),a.a.createElement("li",null,a.a.createElement(f.a,{to:"/leetcode"},"leetcode")))))}),v=function(){return a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon profile"}),"Tony Chen - Software Engineer"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null,"Dear Sir or Madam,"),a.a.createElement("p",null,"If your company can benefit from the contributions of a resourceful and knowledgeable technical professional who seeks to develop solutions with the end user in mind, then i am the candidate that you seek."),a.a.createElement("p",null,"Throughout my career, I have become proficient in numerous platforms, web technologies, programming languages, and application development tools, I constantly strive to find the best solutions, and work hard to ensure that each new feature implemented provides technological advancements for system users. I have played instrumental roles in various project and been involved in the project lifecycle development."),a.a.createElement("p",null,"I am a quick learner with the proven ability to clearly understand problems and find positive solutions through critical thinking, diligence and excellent communication skills. with a solid reputation as dynamic problem solver and out of the box thinker, i consistently deliver solutions that exceed user expectation. I am confident I can do the same of you."),a.a.createElement("p",null,"I am confident in my ability to meet and exceed your expectation for Web Application engineer, and i believe my background provides the skills you require for this position, and i would appreciate the opportunity to further discuss my credentials ability with you during the personal interview."),a.a.createElement("p",null,"Thanks you for your time Interest and consideration."),a.a.createElement("p",null,"Sincerely,"),a.a.createElement("p",null,a.a.createElement("b",null,"Tony Chen")))))},y=(t(212),function(e){function n(){var e;return Object(s.a)(this,n),(e=Object(d.a)(this,Object(c.a)(n).call(this))).state={},e}return Object(m.a)(n,e),Object(u.a)(n,[{key:"render",value:function(){return a.a.createElement("div",null,a.a.createElement("div",{className:"main"},a.a.createElement("div",{className:"personal-info-block"},a.a.createElement("div",{className:"text-block"},a.a.createElement("div",{className:"name"},"Tony Chen"),a.a.createElement("div",{className:"current-position setting--primary-text"},"Software Engineer"),a.a.createElement("div",{className:"contacts"},a.a.createElement("div",{className:"city"},"California, 95131, USA")))),a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon profile"}),"Superior Applications Development"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null,"Highly Skilled in designing, coding, and testing innovative and effective software, User interface(UI), and e-commerce solutions. Strong project leader accomplished in directing cradle-to-grave software developer life cycle( SDLC). Proficient in industry dominant languageds, methodologies, standards, and the best practices, Superior planner and proritlier with a track record for on-time project delivery."),a.a.createElement("p",null,"Seeking a software development position that demands utilization of my knowledge and skills. I have years experience in both development and research positions. I create software with user in mind. I understand the importance of maintainable source code \xa0and I also constantly learning new technologies.")))),a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon work"}),"Career Success"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-title"},"Software Engineer at  8x8 Inc., San Jose"),a.a.createElement("div",{className:"item-caption setting--primary-text"},"October 2015\xa0\xa0\u2013\xa0\xa0October 2018"),a.a.createElement("div",{className:"item-description"},a.a.createElement("ul",null,a.a.createElement("li",null,"Leveraged ReactJS and Electron to build presentation layer for cross-platform telephony / chat desktop applications"),a.a.createElement("li",null,"Experienced in React JS and working with Redux architecture.\xa0"),a.a.createElement("li",null,"Experienced in developing React components. Used Axios with ReactJS for making AJAX Calls. Worked on Webpack for build and webpack-dev-server a server.\xa0"),a.a.createElement("li",null,"Design reusable user interface components in ReactJS and Javascript ES6, Managed application state using Redux"),a.a.createElement("li",null,"Write unit test in Jest and Enzyme to save development efforts"),a.a.createElement("li",null,"Contribute in continuous integration and continuous deployment making pull request using GitLab and Jenkins"),a.a.createElement("li",null,"Working in Agile Methodology and team Scrum, and work with story task"),a.a.createElement("li",null,"Ability and experience to work in a critical, dynamic and challenging environment."),a.a.createElement("li",null,"Excellent understanding of system design and analysis concepts."),a.a.createElement("li",null,"Document work using self documenting technique.")))),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-title"},"Software Engineer at  Mobile Programming LLC."),a.a.createElement("div",{className:"item-caption setting--primary-text"},"October 2005\xa0\xa0\u2013\xa0\xa0October 2015"),a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null,a.a.createElement("strong",null,"A-G Software & Technology, Inc. Ontario, California \xa0")),a.a.createElement("p",null,a.a.createElement("strong",null,"ASP.NET C# / MVC / IOC/ JQuery / KnockoutJS")),a.a.createElement("ul",null,a.a.createElement("li",null,"Resharper, Ninject, Nunit, LINQ, and Design Patterns."),a.a.createElement("li",null,"Using best practices, integrated SAP BusinessObjects (.NET 3.5) with ASP.NET MVC 3 (.NET 4.0)."),a.a.createElement("li",null,"Using Dependency Injection for software design pattern."),a.a.createElement("li",null,"Create user screens from design comps following project style guidelines."),a.a.createElement("li",null,"Create and unit test intricate client side interactions with jQuery and KnockoutJS(MVVM)/DurandalJS(SPA)."),a.a.createElement("li",null,"Create Mobile Site , using AngularJS (SPA )"),a.a.createElement("li",null,"Using Bootstrap do developer a responsive mobile website."),a.a.createElement("li",null,"Develop complex MVC Controller, ViewModels and Helper methods linked to backend database."),a.a.createElement("li",null,"Developed deep understanding of NHibernate configuration and usage."),a.a.createElement("li",null,"Utilized Cassette for combining and optimizing CSS and JavaScript files."),a.a.createElement("li",null,"Attend design meetings and provide feedback based on professional experience."),a.a.createElement("li",null,"Provided mentorship, training and resources to team members.")),a.a.createElement("p",null,a.a.createElement("strong",null,"Prediction Science (ASP.NET C# ) Irvine, California\xa0")),a.a.createElement("ul",null,a.a.createElement("li",null,"Developing code using ASP.net and MS-SQL."),a.a.createElement("li",null,"Working with XML, SOAP, and Web Services\xa0"),a.a.createElement("li",null,"Proficient in JavaScript/AJAX\xa0"),a.a.createElement("li",null,"Create system design documents and devise an implementation strategy for the projects."),a.a.createElement("li",null,"Structure and view data online via the web.\xa0"),a.a.createElement("li",null,"Developed and tested projects according to specifications.")),a.a.createElement("p",null,a.a.createElement("strong",null,"AVM LP (ASP.NET C# / AJAX) Boca Raton, Florida")),a.a.createElement("ul",null,a.a.createElement("li",null,"Building, deploying, and managing enterprise Web Portal Content Management."),a.a.createElement("li",null,"Create Custom Chart \u2013 Pie Chart, Line Chart, and Bar Chart. \xa0"),a.a.createElement("li",null,"Testify the functionality of the Web Product and helped overcome problems regarding UI"),a.a.createElement("li",null,"Web applications written primarily in ASP.NET C# 3.5 / 4.0"),a.a.createElement("li",null,"Applied knowledge of prototype process design and usability process test."),a.a.createElement("li",null,"Recognize the business objectives and constraints and plan accordingly"),a.a.createElement("li",null,"Participate in all phases of projects, from requirements gathering & estimating to deployment"),a.a.createElement("li",null,"Experienced the development and implementation of user interface for commercial web-based")),a.a.createElement("p",null,a.a.createElement("strong",null,"Four Seasons Sunrooms (className ASP / ASP.NET / AJAX) Long Island, NY\xa0")),a.a.createElement("ul",null,a.a.createElement("li",null,"User Interface presentation using Photoshop and cascading style sheet ",a.a.createElement("strong",null,"CSS"),".\xa0"),a.a.createElement("li",null,"Designed database schema"),a.a.createElement("li",null,"Intranet and Website Maintenance and Updates\xa0"),a.a.createElement("li",null,"Translating business requirements into technical architecture and specification\xa0"),a.a.createElement("li",null,"Interacting with a team of developers\xa0"),a.a.createElement("li",null,"Documenting development processes, methodology and standards\xa0"),a.a.createElement("li",null,"Communicating with clients and vendors"))))),a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon education"}),"Education"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-title"},"Bachelor of Art:  Computer Science, University of New York, New York"),a.a.createElement("div",{className:"item-caption setting--primary-text"},"October 1998\xa0\xa0\u2013\xa0\xa0October 2002"),a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null))))),a.a.createElement("div",{className:"aside"},a.a.createElement("div",{className:"aside-group details"},a.a.createElement("div",{className:"title"},"Details"),a.a.createElement("div",{className:"section"},a.a.createElement("div",{className:"text"},"2014 Nunes Dr, California, 95131, USA"),a.a.createElement("div",{className:"text"},"561-901-5698"),a.a.createElement("div",{className:"text setting--primary-text"},"tchen427@gmail.com")),a.a.createElement("div",{className:"section"},a.a.createElement("div",{className:"label"},"Nationality"),a.a.createElement("div",{className:"text"},"Chinese, Asian"))),a.a.createElement("div",{className:"aside-group"},a.a.createElement("div",{className:"title with-icon"},a.a.createElement("div",{className:"title-icon skills"}),"Skills"),a.a.createElement("div",{className:"section"},a.a.createElement("div",{className:"text"},"ReactJS / Redux"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"Javascript / ES5 / ES6"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"CSS / Sass / Stylus"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"NodeJS / npm / "),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"Webpack / Gulp / Grant"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"Gitlab/ Github"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"}))))))}}]),n}(a.a.Component)),x=t(35),b=t(199),w=t(93),E=t.n(w),k=(t(389),t(391),{name:"LeetCode - Algorithm",toggled:!0,children:[{name:"Array",type:"folder",children:[{type:"file",name:"189-rotate-array.js"},{type:"file",name:"26-remove-duplicates-from-sorted-array.js"},{type:"file",name:"283-remove-zero.js"},{type:"file",name:"34-find-first-last-element-array.js"}]},{name:"BackTracking",type:"folder",children:[{type:"file",name:"78-subsets.js"}]},{name:"BinarySearch",type:"folder",children:[{type:"file",name:"704-binarySearch.js"}]},{name:"BreadthFirstSearch",type:"folder",children:[{type:"file",name:"127-word-ladder.js"}]},{name:"DynamicProgramming",type:"folder",children:[{type:"file",name:"322-coin-change.js"}]},{name:"Combination",type:"folder",children:[{type:"file",name:"131-palindrome-partition.js"},{type:"file",name:"17-phone-letter-combine.js"},{type:"file",name:"39-combination-sum.js"},{type:"file",name:"40-combination-sum-ii.js"},{type:"file",name:"77-combinations.js"}]},{name:"BinarySearchTree",type:"folder",children:[{type:"file",name:"100-same-tree.js"},{type:"file",name:"101-symmetric-tree.js"},{type:"file",name:"102-binary-tree-level-order-traversal.js"},{type:"file",name:"103-binary-tree-zigzag-level-order-traversal.js"},{type:"file",name:"104-max-depth-of-binary-tree.js"},{type:"file",name:"105-preorder-to-inorder-traversal.js"},{type:"file",name:"107-binary-tree-level-order-traversal.js"},{type:"file",name:"108-convert-array-bst.js"},{type:"file",name:"111-minimum-depth-of-binary-tree.js"},{type:"file",name:"112-path-sum.js"},{type:"file",name:"144-binary-tree-preorder-traversal.js"},{type:"file",name:"145-binary-tree-postorder-traversal.js"},{type:"file",name:"199-binary-tree-right-side-view.js"},{type:"file",name:"200-number-island.js"},{type:"file",name:"226-invert-binary-tree.js"},{type:"file",name:"230-kth-element.js"},{type:"file",name:"257-binary-tree-paths.js"},{type:"file",name:"513-find-bottom-left-tree-value.js"},{type:"file",name:"515-largest-value-tree-row.js"},{type:"file",name:"655-PrintBST.js"},{type:"file",name:"700-searchBST.js"},{type:"file",name:"94-binary-tree-inorder-traversal.js"},{type:"file",name:"98-validate-binary-search-tree.js"}]},{name:"LinkedList",type:"folder",children:[{type:"file",name:"116-pointers-next-right-node.js"},{type:"file",name:"141-linked-list-cycle.js"},{type:"file",name:"148-sorted-linked-list.js"},{type:"file",name:"19-remove-nth-node-from-end-of-list.js"},{type:"file",name:"2-add-two-linked.js"},{type:"file",name:"203-remove-linked-list-elements.js"},{type:"file",name:"206-reverse-linked-list.js"},{type:"file",name:"21-merge-two-sorted-lists.js"},{type:"file",name:"234-palindrome-linked-list.js"},{type:"file",name:"237-delete-linked-list.js"},{type:"file",name:"83-remove-duplicates-from-sorted-list.js"},{type:"file",name:"876-middle-of-the-linked-list.js"}]},{name:"HashTable",type:"folder",children:[{type:"file",name:"1-two-sum.js"},{type:"file",name:"217-contains-duplicate.js"},{type:"file",name:"766-toeplitz-matrix.js"},{type:"file",name:"771-jewels-and-stones.js"},{type:"file",name:"804-morse-code.js"}]},{name:"Permutations",type:"folder",children:[{type:"file",name:"46-permutations.js"},{type:"file",name:"93-restore-ip-addresses.js"}]},{name:"TwoPointer",type:"folder",children:[{type:"file",name:"167-two-sum-II.js"}]},{name:"_misc",type:"folder",children:[{type:"file",name:"122-best-time-to-buy-and-sell-stock.js"},{type:"file",name:"125-valid-palindrome.js"},{type:"file",name:"344-reverse-string.js"},{type:"file",name:"7-revese-integer.js"}]}]}),S={},T=0;T<k.children.length;T++)for(var j=0;j<k.children[T].children.length;j++)S[k.children[T].children[j].name]=t(393)("./".concat(k.children[T].name,"/").concat(k.children[T].children[j].name));console.log(S);var N=k,L=function(e,n){return-1!==n.name.indexOf(e)},I=function e(n,t,r){return r(t,n)||n.children&&n.children.length&&!!n.children.find(function(n){return e(n,t,r)})},O={tree:{base:{listStyle:"none",backgroundColor:"#fff",margin:0,padding:0,color:"#343d46",fontFamily:"lucida grande ,tahoma,verdana,arial,sans-serif",fontSize:"14px"},node:{base:{position:"relative"},link:{cursor:"pointer",position:"relative",padding:"0px 5px",display:"block"},activeLink:{background:"#31363F"},toggle:{base:{position:"relative",display:"inline-block",verticalAlign:"top",marginLeft:"-5px",height:"24px",width:"24px"},wrapper:{position:"absolute",top:"50%",left:"50%",margin:"-7px 0 0 -7px",height:"14px"},height:14,width:14,arrow:{fill:"#343d46",strokeWidth:0}},header:{base:{display:"inline-block",verticalAlign:"top",color:"#343d46"},connector:{width:"2px",height:"12px",borderLeft:"solid 2px black",borderBottom:"solid 2px black",position:"absolute",top:"0px",left:"-21px"},title:{lineHeight:"24px",verticalAlign:"middle"}},subtree:{listStyle:"none",paddingLeft:"19px"},loading:{color:"#E2C089"}}}},B=function(e){function n(e){var t;return Object(s.a)(this,n),(t=Object(d.a)(this,Object(c.a)(n).call(this,e))).state={data:N,content:""},t.onToggle=t.onToggle.bind(Object(x.a)(Object(x.a)(t))),t}return Object(m.a)(n,e),Object(u.a)(n,[{key:"componentDidMount",value:function(){this.setState({content:S["1-two-sum.js"]}),E.a.highlightAll()}},{key:"componentDidUpdate",value:function(){E.a.highlightAll()}},{key:"onToggle",value:function(e,n){this.state.cursor&&this.setState({cursor:{active:!1}}),e.active=!0,e.children&&(e.toggled=n),this.setState({cursor:e}),"file"===e.type&&this.setState({content:S[e.name]})}},{key:"onFilterMouseUp",value:function(e){var n=e.target.value.trim();if(!n)return this.setState({data:N});var t=function e(n,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:L;if(r(t,n)||!n.children)return n;var a=n.children.filter(function(e){return I(e,t,r)}).map(function(n){return e(n,t,r)});return Object.assign({},n,{children:a})}(N,n);t=function e(n,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:L,a=n.children;if(!a||0===a.length)return Object.assign({},n,{toggled:!1});var i=n.children.filter(function(e){return I(e,t,r)}),l=i.length>0;return l&&(a=i.map(function(n){return e(n,t,r)})),Object.assign({},n,{children:a,toggled:l})}(t,n),this.setState({data:t})}},{key:"render",value:function(){return a.a.createElement("div",{className:"section group"},a.a.createElement("div",{className:"col span_1_of_2"},a.a.createElement("br",null),a.a.createElement("input",{className:"form-control",onKeyUp:this.onFilterMouseUp.bind(this),placeholder:"Search the topic...",type:"text"}),a.a.createElement("br",null),a.a.createElement("br",null),a.a.createElement(b.Treebeard,{style:O,data:this.state.data,onToggle:this.onToggle})),a.a.createElement("div",{className:"col span_2_of_2"},this.state.content&&a.a.createElement("pre",null,a.a.createElement("code",{className:"language-javascript"},this.state.content))))}}]),n}(a.a.Component),A=function(e){function n(){return Object(s.a)(this,n),Object(d.a)(this,Object(c.a)(n).apply(this,arguments))}return Object(m.a)(n,e),Object(u.a)(n,[{key:"render",value:function(){return a.a.createElement("div",{className:"body--share"},a.a.createElement("div",{className:"headerTop"}),a.a.createElement(g,null),a.a.createElement("div",{className:"preview-box"},a.a.createElement("div",{className:"container"},a.a.createElement(h.a,null,a.a.createElement(p.a,{exact:!0,path:"/",component:v}),a.a.createElement(p.a,{path:"/resume",component:y}),a.a.createElement(p.a,{path:"/leetcode",component:B})))))}}]),n}(r.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));l.a.render(a.a.createElement(o.a,null,a.a.createElement(A,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})}},[[201,2,1]]]);
//# sourceMappingURL=main.0ddae968.chunk.js.map